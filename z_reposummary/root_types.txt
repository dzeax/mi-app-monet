===== C:\Users\Usuario\Documents\GitHub\mi-app-monet\types\auth.ts =====
export type Role = 'admin' | 'editor';

export type SessionUser = {
  id: string;
  email: string | null;
  role: Role;
};

export const DEFAULT_ROLE: Role = 'editor';

===== C:\Users\Usuario\Documents\GitHub\mi-app-monet\types\campaign.ts =====
import type { DBType, InvoiceOffice } from '@/data/reference';

export type CampaignRow = {
  id: string;
  date: string;             // ISO: "2025-07-01"
  campaign: string;
  advertiser: string;
  invoiceOffice: InvoiceOffice; // 'DAT' | 'CAR' | 'INT'
  partner: string;
  theme: string;
  price: number;
  priceCurrency: 'EUR';
  type: 'CPL' | 'CPM' | 'CPC' | 'CPA';
  vSent: number;
  routingCosts: number;
  qty: number;
  turnover: number;
  margin: number;
  ecpm: number;
  database: string;
  geo: string;              // "ES", "FR", "UK", ...
  databaseType: DBType;     // 'B2B' | 'B2C' | 'Mixed'
};

// Entrada del formulario (sin id; el provider lo genera)
export type NewCampaignInput = Omit<CampaignRow, 'id'>;

// Tipo interno del store para orden estable
export type RowWithIdx = CampaignRow & { _idx: number };

===== C:\Users\Usuario\Documents\GitHub\mi-app-monet\types\reports.ts =====
// types/reports.ts
import type { DBType } from '@/data/reference';

// MÃ©tricas soportadas en Reports
export type Metric = 'turnover' | 'margin' | 'ecpm' | 'vSent';

export const METRIC_LABELS: Record<Metric, string> = {
  turnover: 'Turnover',
  margin: 'Margin',
  ecpm: 'eCPM',
  vSent: 'V Sent',
};

// Dimensiones por las que podemos agrupar el ranking / tabla
export type GroupBy =
  | 'database'
  | 'partner'
  | 'campaign'
  | 'advertiser'
  | 'theme'
  | 'geo'
  | 'type'
  | 'databaseType';

export const GROUP_LABELS: Record<GroupBy, string> = {
  database: 'Database',
  partner: 'Partner',
  campaign: 'Campaign',
  advertiser: 'Advertiser',
  theme: 'Theme',
  geo: 'GEO',
  type: 'Type',
  databaseType: 'DB Type',
};

// Filtros de alto nivel del reporte
export type ReportFilters = {
  from?: string;                 // yyyy-mm-dd (inclusive)
  to?: string;                   // yyyy-mm-dd (inclusive)
  geos?: string[];               // cÃ³digos en mayÃºsculas (ES, FR, ...)
  partners?: string[];           // nombres visibles
  campaigns?: string[];          // nombres visibles
  advertisers?: string[];        // nombres visibles
  themes?: string[];             // etiquetas
  databases?: string[];          // nombres visibles
  types?: Array<'CPL' | 'CPM' | 'CPC' | 'CPA'>;
  databaseTypes?: DBType[];      // <- tipado fuerte desde catÃ¡logos
  onlyInternalPartners?: boolean;
};

// Fila agregada (resultado de agrupar por GroupBy)
export type AggregateRow = {
  /** clave cruda (ej. nombre de database o partner) */
  key: string;
  /** etiqueta presentable (por si en el futuro mapeamos idsâ†’labels) */
  label: string;

  /** mÃ©tricas agregadas */
  vSent: number;
  turnover: number;
  margin: number;
  /** eCPM ponderado por vSent del agregado */
  ecpm: number;

  /** opcional: suma de qty cuando aplica (CPL, etc.) */
  qty?: number;

  /** nÂº de filas subyacentes en el agregado */
  count: number;
};

// Punto de serie temporal para tendencias
export type TrendPoint = {
  date: string;     // yyyy-mm-dd
  ecpm: number;     // ponderado en ese dÃ­a
  vSent: number;    // total del dÃ­a (Ãºtil para tooltips)
  turnover: number; // total del dÃ­a (Ãºtil para tooltips)
};

// Resultado calculado por el hook de datos
export type ReportData = {
  filteredCount: number;
  kpis: {
    vSent: number;
    turnover: number;
    margin: number;
    ecpm: number;         // ponderado global
    marginPct: number | null;
  };
  ranking: AggregateRow[]; // ordenado y ya cortado por TopN
  trend: TrendPoint[];     // eCPM por dÃ­a (ordenado asc)
};

